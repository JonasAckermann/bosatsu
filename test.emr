package Foo/Bar

export [
   x, z, Either(), Record(), Option()
]

x = 1

def y(x):
  x + 1

z = if x == 1:
  y
else:
  \y -> y + x

struct Record(a, b)

enum Either:
  Left(left)
  Right(right)

enum Option:
  None
  Some(a)

enum List:
  Empty
  NonEmpty(head: a, tail: List[a])

# This gives us enough to implement useful List functions (and is total)
# but not expressible directly
fold = ffi scala org.bykn.edgemar.Std.fold List[a] -> b -> (b -> a -> b) -> b
# TODO: change syntax to, and a special ffi file to control the mapping.
#external def fold(l: List[A], init: b, fn: (b -> a -> b)) -> b

external struct Action[a]

print = ffi scala org.bykn.edgemar.Std.print Int -> Action[Unit]
flatMap = ffi scala org.bykn.edgemar.Std.flatMap Action[a] -> (a -> Action[b]) -> Action[b]
mapAction = ffi scala org.bykn.edgemar.Std.flatMap Action[a] -> (a -> b) -> Action[b]
toAction = ffi scala org.bykn.edgemar.Std.toAction a -> Action[a]
runAction = ffi scala org.bykn.edgemar.Std.runAction Action[a] -> a

def reduce(list, fn):
  match list:
    Empty:
        None
    NonEmpty(head, tail):
        Some(tail.fold(head, fn))

def reverse(list):
  fold(list, Empty, \tail, item -> NonEmpty(item, tail))

def map(list, fn):
  fold(list, Empty, \tail, item -> NonEmpty(fn(item), tail)).reverse

def filter(list, fn):
  rev_filter = fold(list, Empty, \tail, item -> if fn(item):
    NonEmpty(item, tail)
  else:
    tail)

  rev_filter.reverse

def sum(items):
  fold(items, 0, \x, y -> x + y)

enum Bool:
  True
  False

struct Unit

e = Some(1)
sz = match e:
   Some(x):
     z(x)
   None:
     0

hc = ffi scala org.bykn.edgemar.Foo.times Int -> Int

foo = NonEmpty(1, NonEmpty(2, Empty))

act = print(42).flatMap(\u -> toAction(43))
resA = runAction(act)

main = match foo:
  Empty:
    0
  NonEmpty(x, tail):
    hc(1) + foo.map(\x -> 10*x).sum
